var jt=Object.defineProperty;var ht=(e,t)=>{for(var r in t)jt(e,r,{get:t[r],enumerable:!0})};var m=new TextEncoder,b=new TextDecoder,Ke=2**32;function x(...e){let t=e.reduce((a,{length:o})=>a+o,0),r=new Uint8Array(t),n=0;for(let a of e)r.set(a,n),n+=a.length;return r}function Ge(e,t,r){if(t<0||t>=Ke)throw new RangeError(`value must be >= 0 and <= ${Ke-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,t&255],r)}function _e(e){let t=Math.floor(e/Ke),r=e%Ke,n=new Uint8Array(8);return Ge(n,t,0),Ge(n,r,4),n}function He(e){let t=new Uint8Array(4);return Ge(t,e),t}function xe(e){if(Uint8Array.prototype.toBase64)return e.toBase64();let t=32768,r=[];for(let n=0;n<e.length;n+=t)r.push(String.fromCharCode.apply(null,e.subarray(n,n+t)));return btoa(r.join(""))}function y(e){let t=e;return typeof t=="string"&&(t=m.encode(t)),Uint8Array.prototype.toBase64?t.toBase64({alphabet:"base64url",omitPadding:!0}):xe(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function Fe(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);let t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r}function S(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:b.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=b.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Fe(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}var lt={};ht(lt,{JOSEAlgNotAllowed:()=>B,JOSEError:()=>_,JOSENotSupported:()=>f,JWEDecryptionFailed:()=>M,JWEInvalid:()=>c,JWKInvalid:()=>de,JWKSInvalid:()=>ae,JWKSMultipleMatchingKeys:()=>pe,JWKSNoMatchingKey:()=>F,JWKSTimeout:()=>fe,JWSInvalid:()=>h,JWSSignatureVerificationFailed:()=>V,JWTClaimValidationFailed:()=>C,JWTExpired:()=>ne,JWTInvalid:()=>K});var _=class extends Error{static code="ERR_JOSE_GENERIC";code="ERR_JOSE_GENERIC";constructor(t,r){super(t,r),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}},C=class extends _{static code="ERR_JWT_CLAIM_VALIDATION_FAILED";code="ERR_JWT_CLAIM_VALIDATION_FAILED";claim;reason;payload;constructor(t,r,n="unspecified",a="unspecified"){super(t,{cause:{claim:n,reason:a,payload:r}}),this.claim=n,this.reason=a,this.payload=r}},ne=class extends _{static code="ERR_JWT_EXPIRED";code="ERR_JWT_EXPIRED";claim;reason;payload;constructor(t,r,n="unspecified",a="unspecified"){super(t,{cause:{claim:n,reason:a,payload:r}}),this.claim=n,this.reason=a,this.payload=r}},B=class extends _{static code="ERR_JOSE_ALG_NOT_ALLOWED";code="ERR_JOSE_ALG_NOT_ALLOWED"},f=class extends _{static code="ERR_JOSE_NOT_SUPPORTED";code="ERR_JOSE_NOT_SUPPORTED"},M=class extends _{static code="ERR_JWE_DECRYPTION_FAILED";code="ERR_JWE_DECRYPTION_FAILED";constructor(t="decryption operation failed",r){super(t,r)}},c=class extends _{static code="ERR_JWE_INVALID";code="ERR_JWE_INVALID"},h=class extends _{static code="ERR_JWS_INVALID";code="ERR_JWS_INVALID"},K=class extends _{static code="ERR_JWT_INVALID";code="ERR_JWT_INVALID"},de=class extends _{static code="ERR_JWK_INVALID";code="ERR_JWK_INVALID"},ae=class extends _{static code="ERR_JWKS_INVALID";code="ERR_JWKS_INVALID"},F=class extends _{static code="ERR_JWKS_NO_MATCHING_KEY";code="ERR_JWKS_NO_MATCHING_KEY";constructor(t="no applicable key found in the JSON Web Key Set",r){super(t,r)}},pe=class extends _{[Symbol.asyncIterator];static code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";constructor(t="multiple matching keys found in the JSON Web Key Set",r){super(t,r)}},fe=class extends _{static code="ERR_JWKS_TIMEOUT";code="ERR_JWKS_TIMEOUT";constructor(t="request timed out",r){super(t,r)}},V=class extends _{static code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";constructor(t="signature verification failed",r){super(t,r)}};function Ve(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new f(`Unsupported JWE Algorithm: ${e}`)}}var mt=e=>crypto.getRandomValues(new Uint8Array(Ve(e)>>3));var Pe=(e,t)=>{if(t.length<<3!==Ve(e))throw new c("Invalid Initialization Vector length")};var oe=(e,t)=>{let r=e.byteLength<<3;if(r!==t)throw new c(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)};function P(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function N(e,t){return e.name===t}function We(e){return parseInt(e.name.slice(4),10)}function er(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function yt(e,t){if(t&&!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function wt(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!N(e.algorithm,"HMAC"))throw P("HMAC");let n=parseInt(t.slice(2),10);if(We(e.algorithm.hash)!==n)throw P(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!N(e.algorithm,"RSASSA-PKCS1-v1_5"))throw P("RSASSA-PKCS1-v1_5");let n=parseInt(t.slice(2),10);if(We(e.algorithm.hash)!==n)throw P(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!N(e.algorithm,"RSA-PSS"))throw P("RSA-PSS");let n=parseInt(t.slice(2),10);if(We(e.algorithm.hash)!==n)throw P(`SHA-${n}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!N(e.algorithm,"Ed25519"))throw P("Ed25519");break}case"ES256":case"ES384":case"ES512":{if(!N(e.algorithm,"ECDSA"))throw P("ECDSA");let n=er(t);if(e.algorithm.namedCurve!==n)throw P(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}yt(e,r)}function W(e,t,r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!N(e.algorithm,"AES-GCM"))throw P("AES-GCM");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw P(n,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!N(e.algorithm,"AES-KW"))throw P("AES-KW");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw P(n,"algorithm.length");break}case"ECDH":{switch(e.algorithm.name){case"ECDH":case"X25519":break;default:throw P("ECDH or X25519")}break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!N(e.algorithm,"PBKDF2"))throw P("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!N(e.algorithm,"RSA-OAEP"))throw P("RSA-OAEP");let n=parseInt(t.slice(9),10)||1;if(We(e.algorithm.hash)!==n)throw P(`SHA-${n}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}yt(e,r)}function Et(e,t,...r){if(r=r.filter(Boolean),r.length>2){let n=r.pop();e+=`one of type ${r.join(", ")}, or ${n}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var v=(e,...t)=>Et("Key must be ",e,...t);function ze(e,t,...r){return Et(`Key for the ${e} algorithm must be `,t,...r)}function z(e){if(!J(e))throw new Error("CryptoKey instance expected")}function J(e){return e?.[Symbol.toStringTag]==="CryptoKey"}function X(e){return e?.[Symbol.toStringTag]==="KeyObject"}var ue=e=>J(e)||X(e);async function tr(e,t){if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");let r={name:"HMAC",hash:"SHA-256"},n=await crypto.subtle.generateKey(r,!1,["sign"]),a=new Uint8Array(await crypto.subtle.sign(r,n,e)),o=new Uint8Array(await crypto.subtle.sign(r,n,t)),i=0,s=-1;for(;++s<32;)i|=a[s]^o[s];return i===0}async function rr(e,t,r,n,a,o){if(!(t instanceof Uint8Array))throw new TypeError(v(t,"Uint8Array"));let i=parseInt(e.slice(1,4),10),s=await crypto.subtle.importKey("raw",t.subarray(i>>3),"AES-CBC",!1,["decrypt"]),d=await crypto.subtle.importKey("raw",t.subarray(0,i>>3),{hash:`SHA-${i<<1}`,name:"HMAC"},!1,["sign"]),p=x(o,n,r,_e(o.length<<3)),u=new Uint8Array((await crypto.subtle.sign("HMAC",d,p)).slice(0,i>>3)),w;try{w=await tr(a,u)}catch{}if(!w)throw new M;let A;try{A=new Uint8Array(await crypto.subtle.decrypt({iv:n,name:"AES-CBC"},s,r))}catch{}if(!A)throw new M;return A}async function nr(e,t,r,n,a,o){let i;t instanceof Uint8Array?i=await crypto.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(W(t,e,"decrypt"),i=t);try{return new Uint8Array(await crypto.subtle.decrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},i,x(r,a)))}catch{throw new M}}var ve=async(e,t,r,n,a,o)=>{if(!J(t)&&!(t instanceof Uint8Array))throw new TypeError(v(t,"CryptoKey","KeyObject","Uint8Array","JSON Web Key"));if(!n)throw new c("JWE Initialization Vector missing");if(!a)throw new c("JWE Authentication Tag missing");switch(Pe(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&oe(t,parseInt(e.slice(-3),10)),rr(e,t,r,n,a,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&oe(t,parseInt(e.slice(1,4),10)),nr(e,t,r,n,a,o);default:throw new f("Unsupported JWE Content Encryption Algorithm")}};var I=(...e)=>{let t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(let n of t){let a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(let o of a){if(r.has(o))return!1;r.add(o)}}return!0};function ar(e){return typeof e=="object"&&e!==null}var l=e=>{if(!ar(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t};function St(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function At(e,t,r){return e instanceof Uint8Array?crypto.subtle.importKey("raw",e,"AES-KW",!0,[r]):(W(e,t,r),e)}async function he(e,t,r){let n=await At(t,e,"wrapKey");St(n,e);let a=await crypto.subtle.importKey("raw",r,{hash:"SHA-256",name:"HMAC"},!0,["sign"]);return new Uint8Array(await crypto.subtle.wrapKey("raw",a,n,"AES-KW"))}async function le(e,t,r){let n=await At(t,e,"unwrapKey");St(n,e);let a=await crypto.subtle.unwrapKey("raw",r,n,"AES-KW",{hash:"SHA-256",name:"HMAC"},!0,["sign"]);return new Uint8Array(await crypto.subtle.exportKey("raw",a))}var Je=async(e,t)=>{let r=`SHA-${e.slice(-3)}`;return new Uint8Array(await crypto.subtle.digest(r,t))};function Ye(e){return x(He(e.length),e)}async function or(e,t,r){let n=Math.ceil((t>>3)/32),a=new Uint8Array(n*32);for(let o=0;o<n;o++){let i=new Uint8Array(4+e.length+r.length);i.set(He(o+1)),i.set(e,4),i.set(r,4+e.length),a.set(await Je("sha256",i),o*32)}return a.slice(0,t>>3)}async function Te(e,t,r,n,a=new Uint8Array(0),o=new Uint8Array(0)){W(e,"ECDH"),W(t,"ECDH","deriveBits");let i=x(Ye(m.encode(r)),Ye(a),Ye(o),He(n)),s;e.algorithm.name==="X25519"?s=256:s=Math.ceil(parseInt(e.algorithm.namedCurve.slice(-3),10)/8)<<3;let d=new Uint8Array(await crypto.subtle.deriveBits({name:e.algorithm.name,public:e},t,s));return or(d,n,i)}function Ie(e){switch(e.algorithm.namedCurve){case"P-256":case"P-384":case"P-521":return!0;default:return e.algorithm.name==="X25519"}}function ir(e,t){return e instanceof Uint8Array?crypto.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]):(W(e,t,"deriveBits"),e)}var sr=(e,t)=>x(m.encode(e),new Uint8Array([0]),t);async function bt(e,t,r,n){if(!(e instanceof Uint8Array)||e.length<8)throw new c("PBES2 Salt Input must be 8 or more octets");let a=sr(t,e),o=parseInt(t.slice(13,16),10),i={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:a},s=await ir(n,t);return new Uint8Array(await crypto.subtle.deriveBits(i,s,o))}async function Kt(e,t,r,n=2048,a=crypto.getRandomValues(new Uint8Array(16))){let o=await bt(a,e,n,t);return{encryptedKey:await he(e.slice(-6),o,r),p2c:n,p2s:y(a)}}async function _t(e,t,r,n,a){let o=await bt(a,e,n,t);return le(e.slice(-6),o,r)}var Y=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){let{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};var xt=e=>{switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new f(`alg ${e} is not supported either by JOSE or your javascript runtime`)}};async function Ct(e,t,r){return W(t,e,"encrypt"),Y(e,t),new Uint8Array(await crypto.subtle.encrypt(xt(e),t,r))}async function Pt(e,t,r){return W(t,e,"decrypt"),Y(e,t),new Uint8Array(await crypto.subtle.decrypt(xt(e),t,r))}function me(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new f(`Unsupported JWE Algorithm: ${e}`)}}var R=e=>crypto.getRandomValues(new Uint8Array(me(e)>>3));var Jt=(e,t)=>{let r=(e.match(/.{1,64}/g)||[]).join(`
`);return`-----BEGIN ${t}-----
${r}
-----END ${t}-----`},Tt=async(e,t,r)=>{if(X(r)){if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return r.export({format:"pem",type:t})}if(!J(r))throw new TypeError(v(r,"CryptoKey","KeyObject"));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return Jt(xe(new Uint8Array(await crypto.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},It=e=>Tt("public","spki",e),Rt=e=>Tt("private","pkcs8",e),Oe=(e,t,r=0)=>{r===0&&(t.unshift(t.length),t.unshift(6));let n=e.indexOf(t[0],r);if(n===-1)return!1;let a=e.subarray(n,n+t.length);return a.length!==t.length?!1:a.every((o,i)=>o===t[i])||Oe(e,t,n+1)},cr=e=>{switch(!0){case Oe(e,[42,134,72,206,61,3,1,7]):return"P-256";case Oe(e,[43,129,4,0,34]):return"P-384";case Oe(e,[43,129,4,0,35]):return"P-521";default:return}},Ot=async(e,t,r,n,a)=>{let o,i,s=new Uint8Array(atob(r.replace(e,"")).split("").map(p=>p.charCodeAt(0))),d=t==="spki";switch(n){case"PS256":case"PS384":case"PS512":o={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},i=d?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":o={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},i=d?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},i=d?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":o={name:"ECDSA",namedCurve:"P-256"},i=d?["verify"]:["sign"];break;case"ES384":o={name:"ECDSA",namedCurve:"P-384"},i=d?["verify"]:["sign"];break;case"ES512":o={name:"ECDSA",namedCurve:"P-521"},i=d?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{let p=cr(s);o=p?.startsWith("P-")?{name:"ECDH",namedCurve:p}:{name:"X25519"},i=d?[]:["deriveBits"];break}case"Ed25519":case"EdDSA":o={name:"Ed25519"},i=d?["verify"]:["sign"];break;default:throw new f('Invalid or unsupported "alg" (Algorithm) value')}return crypto.subtle.importKey(t,s,o,a?.extractable??!!d,i)},Dt=(e,t,r)=>Ot(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r),qe=(e,t,r)=>Ot(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function vt(e){let t=[],r=0;for(;r<e.length;){let n=Ut(e.subarray(r));t.push(n),r+=n.byteLength}return t}function Ut(e){let t=0,r=e[0]&31;if(t++,r===31){for(r=0;e[t]>=128;)r=r*128+e[t]-128,t++;r=r*128+e[t]-128,t++}let n=0;if(e[t]<128)n=e[t],t++;else if(n===128){for(n=0;e[t+n]!==0||e[t+n+1]!==0;){if(n>e.byteLength)throw new TypeError("invalid indefinite form length");n++}let o=t+n+2;return{byteLength:o,contents:e.subarray(t,t+n),raw:e.subarray(0,o)}}else{let o=e[t]&127;t++,n=0;for(let i=0;i<o;i++)n=n*256+e[t],t++}let a=t+n;return{byteLength:a,contents:e.subarray(t,a),raw:e.subarray(0,a)}}function dr(e){let t=vt(vt(Ut(e).contents)[0].contents);return xe(t[t[0].raw[0]===160?6:5].raw)}var Re;function pr(e){try{Re??=globalThis.process?.getBuiltinModule?.("node:crypto")?.createPublicKey}catch{Re=0}if(Re)try{return new Re(e).export({format:"pem",type:"spki"})}catch{}let t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),r=Fe(t);return Jt(dr(r),"PUBLIC KEY")}var kt=(e,t,r)=>{let n;try{n=pr(e)}catch(a){throw new TypeError("Failed to parse the X.509 certificate",{cause:a})}return qe(n,t,r)};function fr(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new f('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new f('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new f('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new f('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}var De=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');let{algorithm:t,keyUsages:r}=fr(e),n={...e};return delete n.alg,delete n.use,crypto.subtle.importKey("jwk",n,t,e.ext??!e.d,e.key_ops??r)};async function ur(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return qe(e,t,r)}async function hr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0)throw new TypeError('"x509" must be X.509 formatted string');return kt(e,t,r)}async function lr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return Dt(e,t,r)}async function q(e,t,r){if(!l(e))throw new TypeError("JWK must be an object");let n;switch(t??=e.alg,n??=r?.extractable??e.ext,e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return S(e.k);case"RSA":if("oth"in e&&e.oth!==void 0)throw new f('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return De({...e,alg:t,ext:n});default:throw new f('Unsupported "kty" (Key Type) Parameter value')}}async function mr(e,t,r,n,a){if(!(r instanceof Uint8Array))throw new TypeError(v(r,"Uint8Array"));let o=parseInt(e.slice(1,4),10),i=await crypto.subtle.importKey("raw",r.subarray(o>>3),"AES-CBC",!1,["encrypt"]),s=await crypto.subtle.importKey("raw",r.subarray(0,o>>3),{hash:`SHA-${o<<1}`,name:"HMAC"},!1,["sign"]),d=new Uint8Array(await crypto.subtle.encrypt({iv:n,name:"AES-CBC"},i,t)),p=x(a,n,d,_e(a.length<<3)),u=new Uint8Array((await crypto.subtle.sign("HMAC",s,p)).slice(0,o>>3));return{ciphertext:d,tag:u,iv:n}}async function yr(e,t,r,n,a){let o;r instanceof Uint8Array?o=await crypto.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(W(r,e,"encrypt"),o=r);let i=new Uint8Array(await crypto.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},o,t)),s=i.slice(-16);return{ciphertext:i.slice(0,-16),tag:s,iv:n}}var Ue=async(e,t,r,n,a)=>{if(!J(r)&&!(r instanceof Uint8Array))throw new TypeError(v(r,"CryptoKey","KeyObject","Uint8Array","JSON Web Key"));switch(n?Pe(e,n):n=mt(e),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&oe(r,parseInt(e.slice(-3),10)),mr(e,t,r,n,a);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&oe(r,parseInt(e.slice(1,4),10)),yr(e,t,r,n,a);default:throw new f("Unsupported JWE Content Encryption Algorithm")}};async function Mt(e,t,r,n){let a=e.slice(0,7),o=await Ue(a,r,t,n,new Uint8Array(0));return{encryptedKey:o.ciphertext,iv:y(o.iv),tag:y(o.tag)}}async function Nt(e,t,r,n,a){let o=e.slice(0,7);return ve(o,t,r,n,a,new Uint8Array(0))}var Bt=async(e,t,r,n,a)=>{switch(e){case"dir":{if(r!==void 0)throw new c("Encountered unexpected JWE Encrypted Key");return t}case"ECDH-ES":if(r!==void 0)throw new c("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!l(n.epk))throw new c('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(z(t),!Ie(t))throw new f("ECDH with the provided key is not allowed or not supported by your javascript runtime");let o=await q(n.epk,e);z(o);let i,s;if(n.apu!==void 0){if(typeof n.apu!="string")throw new c('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{i=S(n.apu)}catch{throw new c("Failed to base64url decode the apu")}}if(n.apv!==void 0){if(typeof n.apv!="string")throw new c('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{s=S(n.apv)}catch{throw new c("Failed to base64url decode the apv")}}let d=await Te(o,t,e==="ECDH-ES"?n.enc:e,e==="ECDH-ES"?me(n.enc):parseInt(e.slice(-5,-2),10),i,s);if(e==="ECDH-ES")return d;if(r===void 0)throw new c("JWE Encrypted Key missing");return le(e.slice(-6),d,r)}case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(r===void 0)throw new c("JWE Encrypted Key missing");return z(t),Pt(e,t,r)}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(r===void 0)throw new c("JWE Encrypted Key missing");if(typeof n.p2c!="number")throw new c('JOSE Header "p2c" (PBES2 Count) missing or invalid');let o=a?.maxPBES2Count||1e4;if(n.p2c>o)throw new c('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if(typeof n.p2s!="string")throw new c('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let i;try{i=S(n.p2s)}catch{throw new c("Failed to base64url decode the p2s")}return _t(e,t,r,n.p2c,i)}case"A128KW":case"A192KW":case"A256KW":{if(r===void 0)throw new c("JWE Encrypted Key missing");return le(e,t,r)}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(r===void 0)throw new c("JWE Encrypted Key missing");if(typeof n.iv!="string")throw new c('JOSE Header "iv" (Initialization Vector) missing or invalid');if(typeof n.tag!="string")throw new c('JOSE Header "tag" (Authentication Tag) missing or invalid');let o;try{o=S(n.iv)}catch{throw new c("Failed to base64url decode the iv")}let i;try{i=S(n.tag)}catch{throw new c("Failed to base64url decode the tag")}return Nt(e,t,r,o,i)}default:throw new f('Invalid or unsupported "alg" (JWE Algorithm) header value')}};var O=(e,t,r,n,a)=>{if(a.crit!==void 0&&n?.crit===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(i=>typeof i!="string"||i.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;r!==void 0?o=new Map([...Object.entries(r),...t.entries()]):o=t;for(let i of n.crit){if(!o.has(i))throw new f(`Extension Header Parameter "${i}" is not recognized`);if(a[i]===void 0)throw new e(`Extension Header Parameter "${i}" is missing`);if(o.get(i)&&n[i]===void 0)throw new e(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)};var ye=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};function Z(e){return l(e)&&typeof e.kty=="string"}function Lt(e){return e.kty!=="oct"&&typeof e.d=="string"}function $t(e){return e.kty!=="oct"&&typeof e.d>"u"}function Gt(e){return e.kty==="oct"&&typeof e.k=="string"}var ie,Ft=async(e,t,r,n=!1)=>{ie||=new WeakMap;let a=ie.get(e);if(a?.[r])return a[r];let o=await De({...t,alg:r});return n&&Object.freeze(e),a?a[r]=o:ie.set(e,{[r]:o}),o},Er=(e,t)=>{ie||=new WeakMap;let r=ie.get(e);if(r?.[t])return r[t];let n=e.type==="public",a=!!n,o;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}o=e.toCryptoKey(e.asymmetricKeyType,a,n?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");o=e.toCryptoKey(e.asymmetricKeyType,a,[n?"verify":"sign"])}if(e.asymmetricKeyType==="rsa"){let i;switch(t){case"RSA-OAEP":i="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":i="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":i="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":i="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:i},a,n?["encrypt"]:["decrypt"]);o=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:i},a,[n?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){let s=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get(e.asymmetricKeyDetails?.namedCurve);if(!s)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&s==="P-256"&&(o=e.toCryptoKey({name:"ECDSA",namedCurve:s},a,[n?"verify":"sign"])),t==="ES384"&&s==="P-384"&&(o=e.toCryptoKey({name:"ECDSA",namedCurve:s},a,[n?"verify":"sign"])),t==="ES512"&&s==="P-521"&&(o=e.toCryptoKey({name:"ECDSA",namedCurve:s},a,[n?"verify":"sign"])),t.startsWith("ECDH-ES")&&(o=e.toCryptoKey({name:"ECDH",namedCurve:s},a,n?[]:["deriveBits"]))}if(!o)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=o:ie.set(e,{[t]:o}),o},T=async(e,t)=>{if(e instanceof Uint8Array||J(e))return e;if(X(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return Er(e,t)}catch(n){if(n instanceof TypeError)throw n}let r=e.export({format:"jwk"});return Ft(e,r,t)}if(Z(e))return e.k?S(e.k):Ft(e,e,t,!0);throw new Error("unreachable")};var se=e=>e?.[Symbol.toStringTag],Ze=(e,t,r)=>{if(t.use!==void 0){let n;switch(r){case"sign":case"verify":n="sig";break;case"encrypt":case"decrypt":n="enc";break}if(t.use!==n)throw new TypeError(`Invalid key for this operation, its "use" must be "${n}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let n;switch(!0){case(r==="sign"||r==="verify"):case e==="dir":case e.includes("CBC-HS"):n=r;break;case e.startsWith("PBES2"):n="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?n=r==="encrypt"?"wrapKey":"unwrapKey":n=r;break;case(r==="encrypt"&&e.startsWith("RSA")):n="wrapKey";break;case r==="decrypt":n=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(n&&t.key_ops?.includes?.(n)===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${n}" when present`)}return!0},Sr=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(Z(t)){if(Gt(t)&&Ze(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!ue(t))throw new TypeError(ze(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${se(t)} instances for symmetric algorithms must be of type "secret"`)}},Ar=(e,t,r)=>{if(Z(t))switch(r){case"decrypt":case"sign":if(Lt(t)&&Ze(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"encrypt":case"verify":if($t(t)&&Ze(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!ue(t))throw new TypeError(ze(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${se(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case"sign":throw new TypeError(`${se(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${se(t)} instances for asymmetric algorithm decryption must be of type "private"`);default:break}if(t.type==="private")switch(r){case"verify":throw new TypeError(`${se(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${se(t)} instances for asymmetric algorithm encryption must be of type "public"`);default:break}},D=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(e)||/^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(e)?Sr(e,t,r):Ar(e,t,r)};async function we(e,t,r){if(!l(e))throw new c("Flattened JWE must be an object");if(e.protected===void 0&&e.header===void 0&&e.unprotected===void 0)throw new c("JOSE Header missing");if(e.iv!==void 0&&typeof e.iv!="string")throw new c("JWE Initialization Vector incorrect type");if(typeof e.ciphertext!="string")throw new c("JWE Ciphertext missing or incorrect type");if(e.tag!==void 0&&typeof e.tag!="string")throw new c("JWE Authentication Tag incorrect type");if(e.protected!==void 0&&typeof e.protected!="string")throw new c("JWE Protected Header incorrect type");if(e.encrypted_key!==void 0&&typeof e.encrypted_key!="string")throw new c("JWE Encrypted Key incorrect type");if(e.aad!==void 0&&typeof e.aad!="string")throw new c("JWE AAD incorrect type");if(e.header!==void 0&&!l(e.header))throw new c("JWE Shared Unprotected Header incorrect type");if(e.unprotected!==void 0&&!l(e.unprotected))throw new c("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{let re=S(e.protected);n=JSON.parse(b.decode(re))}catch{throw new c("JWE Protected Header is invalid")}if(!I(n,e.header,e.unprotected))throw new c("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");let a={...n,...e.header,...e.unprotected};if(O(c,new Map,r?.crit,n,a),a.zip!==void 0)throw new f('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:o,enc:i}=a;if(typeof o!="string"||!o)throw new c("missing JWE Algorithm (alg) in JWE Header");if(typeof i!="string"||!i)throw new c("missing JWE Encryption Algorithm (enc) in JWE Header");let s=r&&ye("keyManagementAlgorithms",r.keyManagementAlgorithms),d=r&&ye("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(s&&!s.has(o)||!s&&o.startsWith("PBES2"))throw new B('"alg" (Algorithm) Header Parameter value not allowed');if(d&&!d.has(i))throw new B('"enc" (Encryption Algorithm) Header Parameter value not allowed');let p;if(e.encrypted_key!==void 0)try{p=S(e.encrypted_key)}catch{throw new c("Failed to base64url decode the encrypted_key")}let u=!1;typeof t=="function"&&(t=await t(n,e),u=!0),D(o==="dir"?i:o,t,"decrypt");let w=await T(t,o),A;try{A=await Bt(o,w,p,a,r)}catch(re){if(re instanceof TypeError||re instanceof c||re instanceof f)throw re;A=R(i)}let g,E;if(e.iv!==void 0)try{g=S(e.iv)}catch{throw new c("Failed to base64url decode the iv")}if(e.tag!==void 0)try{E=S(e.tag)}catch{throw new c("Failed to base64url decode the tag")}let H=m.encode(e.protected??""),k;e.aad!==void 0?k=x(H,m.encode("."),m.encode(e.aad)):k=H;let ut;try{ut=S(e.ciphertext)}catch{throw new c("Failed to base64url decode the ciphertext")}let te={plaintext:await ve(i,A,ut,g,E,k)};if(e.protected!==void 0&&(te.protectedHeader=n),e.aad!==void 0)try{te.additionalAuthenticatedData=S(e.aad)}catch{throw new c("Failed to base64url decode the aad")}return e.unprotected!==void 0&&(te.sharedUnprotectedHeader=e.unprotected),e.header!==void 0&&(te.unprotectedHeader=e.header),u?{...te,key:w}:te}async function Qe(e,t,r){if(e instanceof Uint8Array&&(e=b.decode(e)),typeof e!="string")throw new c("Compact JWE must be a string or Uint8Array");let{0:n,1:a,2:o,3:i,4:s,length:d}=e.split(".");if(d!==5)throw new c("Invalid Compact JWE");let p=await we({ciphertext:i,iv:o||void 0,protected:n,tag:s||void 0,encrypted_key:a||void 0},t,r),u={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return typeof t=="function"?{...u,key:p.key}:u}async function gr(e,t,r){if(!l(e))throw new c("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(l))throw new c("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new c("JWE Recipients has no members");for(let n of e.recipients)try{return await we({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new M}var ke=Symbol();async function je(e){if(X(e))if(e.type==="secret")e=e.export();else return e.export({format:"jwk"});if(e instanceof Uint8Array)return{kty:"oct",k:y(e)};if(!J(e))throw new TypeError(v(e,"CryptoKey","KeyObject","Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");let{ext:t,key_ops:r,alg:n,use:a,...o}=await crypto.subtle.exportKey("jwk",e);return o}async function br(e){return It(e)}async function Kr(e){return Rt(e)}async function Ee(e){return je(e)}var Me=async(e,t,r,n,a={})=>{let o,i,s;switch(e){case"dir":{s=r;break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(z(r),!Ie(r))throw new f("ECDH with the provided key is not allowed or not supported by your javascript runtime");let{apu:d,apv:p}=a,u;a.epk?u=await T(a.epk,e):u=(await crypto.subtle.generateKey(r.algorithm,!0,["deriveBits"])).privateKey;let{x:w,y:A,crv:g,kty:E}=await Ee(u),H=await Te(r,u,e==="ECDH-ES"?t:e,e==="ECDH-ES"?me(t):parseInt(e.slice(-5,-2),10),d,p);if(i={epk:{x:w,crv:g,kty:E}},E==="EC"&&(i.epk.y=A),d&&(i.apu=y(d)),p&&(i.apv=y(p)),e==="ECDH-ES"){s=H;break}s=n||R(t);let k=e.slice(-6);o=await he(k,H,s);break}case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{s=n||R(t),z(r),o=await Ct(e,r,s);break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{s=n||R(t);let{p2c:d,p2s:p}=a;({encryptedKey:o,...i}=await Kt(e,r,s,d,p));break}case"A128KW":case"A192KW":case"A256KW":{s=n||R(t),o=await he(e,r,s);break}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{s=n||R(t);let{iv:d}=a;({encryptedKey:o,...i}=await Mt(e,r,s,d));break}default:throw new f('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:s,encryptedKey:o,parameters:i}};var L=class{_plaintext;_protectedHeader;_sharedUnprotectedHeader;_unprotectedHeader;_aad;_cek;_iv;_keyManagementParameters;constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=t}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}async encrypt(t,r){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new c("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!I(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new c("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let n={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(O(c,new Map,r?.crit,this._protectedHeader,n),n.zip!==void 0)throw new f('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');let{alg:a,enc:o}=n;if(typeof a!="string"||!a)throw new c('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(typeof o!="string"||!o)throw new c('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let i;if(this._cek&&(a==="dir"||a==="ECDH-ES"))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${a}`);D(a==="dir"?o:a,t,"encrypt");let s;{let H,k=await T(t,a);({cek:s,encryptedKey:i,parameters:H}=await Me(a,o,k,this._cek,this._keyManagementParameters)),H&&(r&&ke in r?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...H}:this.setUnprotectedHeader(H):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...H}:this.setProtectedHeader(H))}let d,p,u;this._protectedHeader?p=m.encode(y(JSON.stringify(this._protectedHeader))):p=m.encode(""),this._aad?(u=y(this._aad),d=x(p,m.encode("."),m.encode(u))):d=p;let{ciphertext:w,tag:A,iv:g}=await Ue(o,this._plaintext,s,this._iv,d),E={ciphertext:y(w)};return g&&(E.iv=y(g)),A&&(E.tag=y(A)),i&&(E.encrypted_key=y(i)),u&&(E.aad=u),this._protectedHeader&&(E.protected=b.decode(p)),this._sharedUnprotectedHeader&&(E.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(E.header=this._unprotectedHeader),E}};var et=class{parent;unprotectedHeader;key;options;constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addRecipient(...t){return this.parent.addRecipient(...t)}encrypt(...t){return this.parent.encrypt(...t)}done(){return this.parent}},tt=class{_plaintext;_recipients=[];_protectedHeader;_unprotectedHeader;_aad;constructor(t){this._plaintext=t}addRecipient(t,r){let n=new et(this,t,{crit:r?.crit});return this._recipients.push(n),n}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}async encrypt(){if(!this._recipients.length)throw new c("at least one recipient must be added");if(this._recipients.length===1){let[a]=this._recipients,o=await new L(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(a.unprotectedHeader).encrypt(a.key,{...a.options}),i={ciphertext:o.ciphertext,iv:o.iv,recipients:[{}],tag:o.tag};return o.aad&&(i.aad=o.aad),o.protected&&(i.protected=o.protected),o.unprotected&&(i.unprotected=o.unprotected),o.encrypted_key&&(i.recipients[0].encrypted_key=o.encrypted_key),o.header&&(i.recipients[0].header=o.header),i}let t;for(let a=0;a<this._recipients.length;a++){let o=this._recipients[a];if(!I(this._protectedHeader,this._unprotectedHeader,o.unprotectedHeader))throw new c("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let i={...this._protectedHeader,...this._unprotectedHeader,...o.unprotectedHeader},{alg:s}=i;if(typeof s!="string"||!s)throw new c('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(s==="dir"||s==="ECDH-ES")throw new c('"dir" and "ECDH-ES" alg may only be used with a single recipient');if(typeof i.enc!="string"||!i.enc)throw new c('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(!t)t=i.enc;else if(t!==i.enc)throw new c('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');if(O(c,new Map,o.options.crit,this._protectedHeader,i),i.zip!==void 0)throw new f('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}let r=R(t),n={ciphertext:"",iv:"",recipients:[],tag:""};for(let a=0;a<this._recipients.length;a++){let o=this._recipients[a],i={};n.recipients.push(i);let d={...this._protectedHeader,...this._unprotectedHeader,...o.unprotectedHeader}.alg.startsWith("PBES2")?2048+a:void 0;if(a===0){let g=await new L(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(r).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(o.unprotectedHeader).setKeyManagementParameters({p2c:d}).encrypt(o.key,{...o.options,[ke]:!0});n.ciphertext=g.ciphertext,n.iv=g.iv,n.tag=g.tag,g.aad&&(n.aad=g.aad),g.protected&&(n.protected=g.protected),g.unprotected&&(n.unprotected=g.unprotected),i.encrypted_key=g.encrypted_key,g.header&&(i.header=g.header);continue}let p=o.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg;D(p==="dir"?t:p,o.key,"encrypt");let u=await T(o.key,p),{encryptedKey:w,parameters:A}=await Me(p,t,u,r,{p2c:d});i.encrypted_key=y(w),(o.unprotectedHeader||A)&&(i.header={...o.unprotectedHeader,...A})}return n}};var Ne=(e,t)=>{let r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};default:throw new f(`alg ${e} is not supported either by JOSE or your javascript runtime`)}};var Be=async(e,t,r)=>{if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(v(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}return wt(t,e,r),t};var Vt=async(e,t,r,n)=>{let a=await Be(e,t,"verify");Y(e,a);let o=Ne(e,a.algorithm);try{return await crypto.subtle.verify(o,a,r,n)}catch{return!1}};async function Se(e,t,r){if(!l(e))throw new h("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new h('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new h("JWS Protected Header incorrect type");if(e.payload===void 0)throw new h("JWS Payload missing");if(typeof e.signature!="string")throw new h("JWS Signature missing or incorrect type");if(e.header!==void 0&&!l(e.header))throw new h("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{let k=S(e.protected);n=JSON.parse(b.decode(k))}catch{throw new h("JWS Protected Header is invalid")}if(!I(n,e.header))throw new h("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let a={...n,...e.header},o=O(h,new Map([["b64",!0]]),r?.crit,n,a),i=!0;if(o.has("b64")&&(i=n.b64,typeof i!="boolean"))throw new h('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:s}=a;if(typeof s!="string"||!s)throw new h('JWS "alg" (Algorithm) Header Parameter missing or invalid');let d=r&&ye("algorithms",r.algorithms);if(d&&!d.has(s))throw new B('"alg" (Algorithm) Header Parameter value not allowed');if(i){if(typeof e.payload!="string")throw new h("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new h("JWS Payload must be a string or an Uint8Array instance");let p=!1;typeof t=="function"&&(t=await t(n,e),p=!0),D(s,t,"verify");let u=x(m.encode(e.protected??""),m.encode("."),typeof e.payload=="string"?m.encode(e.payload):e.payload),w;try{w=S(e.signature)}catch{throw new h("Failed to base64url decode the signature")}let A=await T(t,s);if(!await Vt(s,A,w,u))throw new V;let E;if(i)try{E=S(e.payload)}catch{throw new h("Failed to base64url decode the payload")}else typeof e.payload=="string"?E=m.encode(e.payload):E=e.payload;let H={payload:E};return e.protected!==void 0&&(H.protectedHeader=n),e.header!==void 0&&(H.unprotectedHeader=e.header),p?{...H,key:A}:H}async function rt(e,t,r){if(e instanceof Uint8Array&&(e=b.decode(e)),typeof e!="string")throw new h("Compact JWS must be a string or Uint8Array");let{0:n,1:a,2:o,length:i}=e.split(".");if(i!==3)throw new h("Invalid Compact JWS");let s=await Se({payload:a,protected:n,signature:o},t,r),d={payload:s.payload,protectedHeader:s.protectedHeader};return typeof t=="function"?{...d,key:s.key}:d}async function _r(e,t,r){if(!l(e))throw new h("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(l))throw new h("JWS Signatures missing or incorrect type");for(let n of e.signatures)try{return await Se({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch{}throw new V}var U=e=>Math.floor(e.getTime()/1e3);var Hr=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,Q=e=>{let t=Hr.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");let r=parseFloat(t[2]),n=t[3].toLowerCase(),a;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*60);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*3600);break;case"day":case"days":case"d":a=Math.round(r*86400);break;case"week":case"weeks":case"w":a=Math.round(r*604800);break;default:a=Math.round(r*31557600);break}return t[1]==="-"||t[4]==="ago"?-a:a};var zt=e=>e.toLowerCase().replace(/^application\//,""),xr=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,ce=(e,t,r={})=>{let n;try{n=JSON.parse(b.decode(t))}catch{}if(!l(n))throw new K("JWT Claims Set must be a top-level JSON object");let{typ:a}=r;if(a&&(typeof e.typ!="string"||zt(e.typ)!==zt(a)))throw new C('unexpected "typ" JWT header value',n,"typ","check_failed");let{requiredClaims:o=[],issuer:i,subject:s,audience:d,maxTokenAge:p}=r,u=[...o];p!==void 0&&u.push("iat"),d!==void 0&&u.push("aud"),s!==void 0&&u.push("sub"),i!==void 0&&u.push("iss");for(let E of new Set(u.reverse()))if(!(E in n))throw new C(`missing required "${E}" claim`,n,E,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(n.iss))throw new C('unexpected "iss" claim value',n,"iss","check_failed");if(s&&n.sub!==s)throw new C('unexpected "sub" claim value',n,"sub","check_failed");if(d&&!xr(n.aud,typeof d=="string"?[d]:d))throw new C('unexpected "aud" claim value',n,"aud","check_failed");let w;switch(typeof r.clockTolerance){case"string":w=Q(r.clockTolerance);break;case"number":w=r.clockTolerance;break;case"undefined":w=0;break;default:throw new TypeError("Invalid clockTolerance option type")}let{currentDate:A}=r,g=U(A||new Date);if((n.iat!==void 0||p)&&typeof n.iat!="number")throw new C('"iat" claim must be a number',n,"iat","invalid");if(n.nbf!==void 0){if(typeof n.nbf!="number")throw new C('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>g+w)throw new C('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(n.exp!==void 0){if(typeof n.exp!="number")throw new C('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=g-w)throw new ne('"exp" claim timestamp check failed',n,"exp","check_failed")}if(p){let E=g-n.iat,H=typeof p=="number"?p:Q(p);if(E-w>H)throw new ne('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(E<0-w)throw new C('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n};async function Cr(e,t,r){let n=await rt(e,t,r);if(n.protectedHeader.crit?.includes("b64")&&n.protectedHeader.b64===!1)throw new K("JWTs MUST NOT use unencoded payload");let o={payload:ce(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...o,key:n.key}:o}async function Pr(e,t,r){let n=await Qe(e,t,r),a=ce(n.protectedHeader,n.plaintext,r),{protectedHeader:o}=n;if(o.iss!==void 0&&o.iss!==a.iss)throw new C('replicated "iss" claim header parameter mismatch',a,"iss","mismatch");if(o.sub!==void 0&&o.sub!==a.sub)throw new C('replicated "sub" claim header parameter mismatch',a,"sub","mismatch");if(o.aud!==void 0&&JSON.stringify(o.aud)!==JSON.stringify(a.aud))throw new C('replicated "aud" claim header parameter mismatch',a,"aud","mismatch");let i={payload:a,protectedHeader:o};return typeof t=="function"?{...i,key:n.key}:i}var Ae=class{_flattened;constructor(t){this._flattened=new L(t)}setContentEncryptionKey(t){return this._flattened.setContentEncryptionKey(t),this}setInitializationVector(t){return this._flattened.setInitializationVector(t),this}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}setKeyManagementParameters(t){return this._flattened.setKeyManagementParameters(t),this}async encrypt(t,r){let n=await this._flattened.encrypt(t,r);return[n.protected,n.encrypted_key,n.iv,n.ciphertext,n.tag].join(".")}};var Xt=async(e,t,r)=>{let n=await Be(e,t,"sign");Y(e,n);let a=await crypto.subtle.sign(Ne(e,n.algorithm),n,r);return new Uint8Array(a)};var j=class{_payload;_protectedHeader;_unprotectedHeader;constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new h("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!I(this._protectedHeader,this._unprotectedHeader))throw new h("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let n={...this._protectedHeader,...this._unprotectedHeader},a=O(h,new Map([["b64",!0]]),r?.crit,this._protectedHeader,n),o=!0;if(a.has("b64")&&(o=this._protectedHeader.b64,typeof o!="boolean"))throw new h('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:i}=n;if(typeof i!="string"||!i)throw new h('JWS "alg" (Algorithm) Header Parameter missing or invalid');D(i,t,"sign");let s=this._payload;o&&(s=m.encode(y(s)));let d;this._protectedHeader?d=m.encode(y(JSON.stringify(this._protectedHeader))):d=m.encode("");let p=x(d,m.encode("."),s),u=await T(t,i),w=await Xt(i,u,p),A={signature:y(w),payload:""};return o&&(A.payload=b.decode(s)),this._unprotectedHeader&&(A.header=this._unprotectedHeader),this._protectedHeader&&(A.protected=b.decode(d)),A}};var ge=class{_flattened;constructor(t){this._flattened=new j(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){let n=await this._flattened.sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`}};var nt=class{parent;protectedHeader;unprotectedHeader;options;key;constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setProtectedHeader(t){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=t,this}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addSignature(...t){return this.parent.addSignature(...t)}sign(...t){return this.parent.sign(...t)}done(){return this.parent}},at=class{_payload;_signatures=[];constructor(t){this._payload=t}addSignature(t,r){let n=new nt(this,t,r);return this._signatures.push(n),n}async sign(){if(!this._signatures.length)throw new h("at least one signature must be added");let t={signatures:[],payload:""};for(let r=0;r<this._signatures.length;r++){let n=this._signatures[r],a=new j(this._payload);a.setProtectedHeader(n.protectedHeader),a.setUnprotectedHeader(n.unprotectedHeader);let{payload:o,...i}=await a.sign(n.key,n.options);if(r===0)t.payload=o;else if(t.payload!==o)throw new h("inconsistent use of JWS Unencoded Payload (RFC7797)");t.signatures.push(i)}return t}};function ee(e,t){if(!Number.isFinite(t))throw new TypeError(`Invalid ${e} input`);return t}var $=class{_payload;constructor(t={}){if(!l(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:ee("setNotBefore",t)}:t instanceof Date?this._payload={...this._payload,nbf:ee("setNotBefore",U(t))}:this._payload={...this._payload,nbf:U(new Date)+Q(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:ee("setExpirationTime",t)}:t instanceof Date?this._payload={...this._payload,exp:ee("setExpirationTime",U(t))}:this._payload={...this._payload,exp:U(new Date)+Q(t)},this}setIssuedAt(t){return typeof t>"u"?this._payload={...this._payload,iat:U(new Date)}:t instanceof Date?this._payload={...this._payload,iat:ee("setIssuedAt",U(t))}:typeof t=="string"?this._payload={...this._payload,iat:ee("setIssuedAt",U(new Date)+Q(t))}:this._payload={...this._payload,iat:ee("setIssuedAt",t)},this}};var ot=class extends ${_protectedHeader;setProtectedHeader(t){return this._protectedHeader=t,this}async sign(t,r){let n=new ge(m.encode(JSON.stringify(this._payload)));if(n.setProtectedHeader(this._protectedHeader),Array.isArray(this._protectedHeader?.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new K("JWTs MUST NOT use unencoded payload");return n.sign(t,r)}};var it=class extends ${_cek;_iv;_keyManagementParameters;_protectedHeader;_replicateIssuerAsHeader;_replicateSubjectAsHeader;_replicateAudienceAsHeader;setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(t,r){let n=new Ae(m.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),n.setProtectedHeader(this._protectedHeader),this._iv&&n.setInitializationVector(this._iv),this._cek&&n.setContentEncryptionKey(this._cek),this._keyManagementParameters&&n.setKeyManagementParameters(this._keyManagementParameters),n.encrypt(t,r)}};var G=(e,t)=>{if(typeof e!="string"||!e)throw new de(`${t} missing or invalid`)};async function Yt(e,t){let r;if(Z(e))r=e;else if(ue(e))r=await Ee(e);else throw new TypeError(v(e,"CryptoKey","KeyObject","JSON Web Key"));if(t??="sha256",t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let n;switch(r.kty){case"EC":G(r.crv,'"crv" (Curve) Parameter'),G(r.x,'"x" (X Coordinate) Parameter'),G(r.y,'"y" (Y Coordinate) Parameter'),n={crv:r.crv,kty:r.kty,x:r.x,y:r.y};break;case"OKP":G(r.crv,'"crv" (Subtype of Key Pair) Parameter'),G(r.x,'"x" (Public Key) Parameter'),n={crv:r.crv,kty:r.kty,x:r.x};break;case"RSA":G(r.e,'"e" (Exponent) Parameter'),G(r.n,'"n" (Modulus) Parameter'),n={e:r.e,kty:r.kty,n:r.n};break;case"oct":G(r.k,'"k" (Key Value) Parameter'),n={k:r.k,kty:r.kty};break;default:throw new f('"kty" (Key Type) Parameter missing or unsupported')}let a=m.encode(JSON.stringify(n));return y(await Je(t,a))}async function Wr(e,t){t??="sha256";let r=await Yt(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function vr(e,t){let r={...e,...t?.header};if(!l(r.jwk))throw new h('"jwk" (JSON Web Key) Header Parameter must be a JSON object');let n=await q({...r.jwk,ext:!0},r.alg);if(n instanceof Uint8Array||n.type!=="public")throw new h('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function Jr(e){switch(typeof e=="string"&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new f('Unsupported "alg" value for a JSON Web Key Set')}}function Tr(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(Ir)}function Ir(e){return l(e)}function Zt(e){return typeof structuredClone=="function"?structuredClone(e):JSON.parse(JSON.stringify(e))}var st=class{_jwks;_cached=new WeakMap;constructor(t){if(!Tr(t))throw new ae("JSON Web Key Set malformed");this._jwks=Zt(t)}async getKey(t,r){let{alg:n,kid:a}={...t,...r?.header},o=Jr(n),i=this._jwks.keys.filter(p=>{let u=o===p.kty;if(u&&typeof a=="string"&&(u=a===p.kid),u&&typeof p.alg=="string"&&(u=n===p.alg),u&&typeof p.use=="string"&&(u=p.use==="sig"),u&&Array.isArray(p.key_ops)&&(u=p.key_ops.includes("verify")),u)switch(n){case"ES256":u=p.crv==="P-256";break;case"ES384":u=p.crv==="P-384";break;case"ES512":u=p.crv==="P-521";break;case"Ed25519":case"EdDSA":u=p.crv==="Ed25519";break}return u}),{0:s,length:d}=i;if(d===0)throw new F;if(d!==1){let p=new pe,{_cached:u}=this;throw p[Symbol.asyncIterator]=async function*(){for(let w of i)try{yield await qt(u,w,n)}catch{}},p}return qt(this._cached,s,n)}};async function qt(e,t,r){let n=e.get(t)||e.set(t,{}).get(t);if(n[r]===void 0){let a=await q({...t,ext:!0},r);if(a instanceof Uint8Array||a.type!=="public")throw new ae("JSON Web Key Set members must be public keys");n[r]=a}return n[r]}function Le(e){let t=new st(e),r=async(n,a)=>t.getKey(n,a);return Object.defineProperties(r,{jwks:{value:()=>Zt(t._jwks),enumerable:!0,configurable:!1,writable:!1}}),r}function Rr(){return typeof WebSocketPair<"u"||typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"||typeof EdgeRuntime<"u"&&EdgeRuntime==="vercel"}var ct;(typeof navigator>"u"||!navigator.userAgent?.startsWith?.("Mozilla/5.0 "))&&(ct="jose/v6.0.5");var Or=Symbol();async function Dr(e,t){let r=await(t?.[Or]||fetch)(e,{method:"GET",signal:t.signal,redirect:"manual",headers:t.headers}).catch(n=>{throw n.name==="TimeoutError"?new fe:n});if(r.status!==200)throw new _("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await r.json()}catch{throw new _("Failed to parse the JSON Web Key Set HTTP response as JSON")}}var $e=Symbol();function Ur(e,t){return!(typeof e!="object"||e===null||!("uat"in e)||typeof e.uat!="number"||Date.now()-e.uat>=t||!("jwks"in e)||!l(e.jwks)||!Array.isArray(e.jwks.keys)||!Array.prototype.every.call(e.jwks.keys,l))}var dt=class{_url;_timeoutDuration;_cooldownDuration;_cacheMaxAge;_jwksTimestamp;_pendingFetch;_options;_local;_cache;constructor(t,r){if(!(t instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(t.href),this._options={headers:r?.headers},this._timeoutDuration=typeof r?.timeoutDuration=="number"?r?.timeoutDuration:5e3,this._cooldownDuration=typeof r?.cooldownDuration=="number"?r?.cooldownDuration:3e4,this._cacheMaxAge=typeof r?.cacheMaxAge=="number"?r?.cacheMaxAge:6e5,r?.[$e]!==void 0&&(this._cache=r?.[$e],Ur(r?.[$e],this._cacheMaxAge)&&(this._jwksTimestamp=this._cache.uat,this._local=Le(this._cache.jwks)))}coolingDown(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cooldownDuration:!1}fresh(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cacheMaxAge:!1}async getKey(t,r){(!this._local||!this.fresh())&&await this.reload();try{return await this._local(t,r)}catch(n){if(n instanceof F&&this.coolingDown()===!1)return await this.reload(),this._local(t,r);throw n}}async reload(){this._pendingFetch&&Rr()&&(this._pendingFetch=void 0);let t=new Headers(this._options.headers);ct&&!t.has("User-Agent")&&(t.set("User-Agent",ct),this._options.headers=Object.fromEntries(t.entries())),t.has("accept")||(t.set("accept","application/json"),t.append("accept","application/jwk-set+json")),this._pendingFetch||=Dr(this._url.href,{headers:t,signal:AbortSignal.timeout(this._timeoutDuration)}).then(r=>{this._local=Le(r),this._cache&&(this._cache.uat=Date.now(),this._cache.jwks=r),this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(r=>{throw this._pendingFetch=void 0,r}),await this._pendingFetch}};function kr(e,t){let r=new dt(e,t),n=async(a,o)=>r.getKey(a,o);return Object.defineProperties(n,{coolingDown:{get:()=>r.coolingDown(),enumerable:!0,configurable:!1},fresh:{get:()=>r.fresh(),enumerable:!0,configurable:!1},reload:{value:()=>r.reload(),enumerable:!0,configurable:!1,writable:!1},reloading:{get:()=>!!r._pendingFetch,enumerable:!0,configurable:!1},jwks:{value:()=>r._local?.jwks(),enumerable:!0,configurable:!1,writable:!1}}),n}var pt=class extends ${encode(){let t=y(JSON.stringify({alg:"none"})),r=y(JSON.stringify(this._payload));return`${t}.${r}.`}static decode(t,r){if(typeof t!="string")throw new K("Unsecured JWT must be a string");let{0:n,1:a,2:o,length:i}=t.split(".");if(i!==3||o!=="")throw new K("Invalid Unsecured JWT");let s;try{if(s=JSON.parse(b.decode(S(n))),s.alg!=="none")throw new Error}catch{throw new K("Invalid Unsecured JWT")}return{payload:ce(s,S(a),r),header:s}}};var Qt={};ht(Qt,{decode:()=>be,encode:()=>Mr});var Mr=y,be=S;function Nr(e){let t;if(typeof e=="string"){let r=e.split(".");(r.length===3||r.length===5)&&([t]=r)}else if(typeof e=="object"&&e)if("protected"in e)t=e.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof t!="string"||!t)throw new Error;let r=JSON.parse(b.decode(be(t)));if(!l(r))throw new Error;return r}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function Br(e){if(typeof e!="string")throw new K("JWTs must use Compact JWS serialization, JWT must be a string");let{1:t,length:r}=e.split(".");if(r===5)throw new K("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new K("Invalid JWT");if(!t)throw new K("JWTs must contain a payload");let n;try{n=be(t)}catch{throw new K("Failed to base64url decode the payload")}let a;try{a=JSON.parse(b.decode(n))}catch{throw new K("Failed to parse the decoded payload as JSON")}if(!l(a))throw new K("Invalid JWT Claims Set");return a}function ft(e){let t=e?.modulusLength??2048;if(typeof t!="number"||t<2048)throw new f("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Lr(e,t){let r,n;switch(e){case"PS256":case"PS384":case"PS512":r={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ft(t)},n=["sign","verify"];break;case"RS256":case"RS384":case"RS512":r={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ft(t)},n=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":r={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ft(t)},n=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":r={name:"ECDSA",namedCurve:"P-256"},n=["sign","verify"];break;case"ES384":r={name:"ECDSA",namedCurve:"P-384"},n=["sign","verify"];break;case"ES512":r={name:"ECDSA",namedCurve:"P-521"},n=["sign","verify"];break;case"Ed25519":case"EdDSA":{n=["sign","verify"],r={name:"Ed25519"};break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{n=["deriveBits"];let a=t?.crv??"P-256";switch(a){case"P-256":case"P-384":case"P-521":{r={name:"ECDH",namedCurve:a};break}case"X25519":r={name:"X25519"};break;default:throw new f("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, and X25519")}break}default:throw new f('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return crypto.subtle.generateKey(r,t?.extractable??!1,n)}async function $r(e,t){let r,n,a;switch(e){case"HS256":case"HS384":case"HS512":r=parseInt(e.slice(-3),10),n={name:"HMAC",hash:`SHA-${r}`,length:r},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r=parseInt(e.slice(-3),10),crypto.getRandomValues(new Uint8Array(r>>3));case"A128KW":case"A192KW":case"A256KW":r=parseInt(e.slice(1,4),10),n={name:"AES-KW",length:r},a=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.slice(1,4),10),n={name:"AES-GCM",length:r},a=["encrypt","decrypt"];break;default:throw new f('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return crypto.subtle.generateKey(n,t?.extractable??!1,a)}var Ds="WebCryptoAPI";export{Ae as CompactEncrypt,ge as CompactSign,vr as EmbeddedJWK,it as EncryptJWT,L as FlattenedEncrypt,j as FlattenedSign,tt as GeneralEncrypt,at as GeneralSign,ot as SignJWT,pt as UnsecuredJWT,Qt as base64url,Yt as calculateJwkThumbprint,Wr as calculateJwkThumbprintUri,Qe as compactDecrypt,rt as compactVerify,Le as createLocalJWKSet,kr as createRemoteJWKSet,Ds as cryptoRuntime,Br as decodeJwt,Nr as decodeProtectedHeader,lt as errors,Ee as exportJWK,Kr as exportPKCS8,br as exportSPKI,we as flattenedDecrypt,Se as flattenedVerify,gr as generalDecrypt,_r as generalVerify,Lr as generateKeyPair,$r as generateSecret,q as importJWK,lr as importPKCS8,ur as importSPKI,hr as importX509,$e as jwksCache,Pr as jwtDecrypt,Cr as jwtVerify};
